- 총 9장, 313p

### 1장. C언어의 개요

p6.

- compile: source file -> object file
- linking: object file -> exe file
- 확장자 .c -> .obj -> linking -> .exe
- linking, linker

p20.

- main() 반드시 존재

p22.

- compiler: token 분리, 규칙 검사, 실행

### 2장. 자료형과 선행처리기

34p.

- 문자열 상수 "", 보관 시 문자열 끝에 null ('\0') 추가됨.

37p.

- 정수형 int
    - 2byte: short, unsigned short
    - 4byte: int, unsigned int, long, unsigned long
    - 8biye: long long, unsigned long long
- 실수형 double, 부동 소수점 표현
    - 4byte: float
    - 8byte: double, long double
- 문자형 char 8bit, ASCII
    - 1byte: char, unsigned char

51p.

- 1.선행처리, 2.컴파일, 3.링킹
- #include, #define, #if, #else, #elif, #endif
- 헤더파일 확장자 .h
- 표준헤더파일: ctype, math, stdlib, stdio, string, time ...

53p.

- macro, #define, #undef
- 매크로 상수 정의, 매크로 함수 정의
- 단순 치환 방식
- 상수로 쓰는 느낌인듯

### 3장. 입출력함수와 연산자

67p.

- <stdio.h>: printf(), putchar(), puts()
- scanf(), getchar(), gets()

69p.

- 출력 양식 변환기호: %d, %ld, %lld, %u, %o, %x, %f, %lf, %e, %c, %s, %p

86p.

- sizeof(), cast(), &: 피연산자의 주소, *: 피연산자의 내용

### 4장. 선택 제어문과 반복 제어문

96p.

- if, switch, goto, for, while, do while, break, continue

### 5장. 함수와 기억 클래스

141p.

- stdio.h, conio.h, string.h, math.h, ctype.h, stdlib.h

153p.

- call by reference
- `&`: 주소 연산자
- `*`: 포인터 연산자

157p.

- 기억 클래스 (storage class): 각 변수의 유효범위와 존속 기간을 결정하는 것
- 자동변수(auto variables), 정적변수(static variables), 외부변수(extern variables), 레지스터 변수(register variables)로 나눔.

### 6장. 배열과 포인터

192p.

- 포인터: 데이터가 저장된 기억 장소의 주소
- 변수의 주소값을 갖는 특별한 변수로 프로그래머가 포인터를 사용하여 직접 기억공간에 접근할 수 있는 방법을 제공함으로써 기억공간에 저장된 변수와 함수의 주소에 직접 접근하여 기억공간의 효율적 이용을 가능하게
  해준다.
- 포인터 변수의 선언 변수명 앞에 `*` 사용

200p.

- 포인터 연산: p 1 증가 시키면 실제 증가되는 주소는 *p 자료형의 byte 수 만큼 증가
- ex. p=100, int *p, (p+3)의 번지 = 100 + (3 * 4)번지
- 포인터 연산자: +, -, ++, --

212p.

- 배열과 포인터의 차이점: 기억공간의 확보 방식
- 배열: 기억 공간 중에 자료 영역을 고정적으로 확보
- 포인터: 기억 공간 중에서 자료 영역을 유동적으로 확보
- 포인터는 필요시에만 자료용 기억공간 확보하고 그렇지 않은 경우 확보하지 않음.
- 자료의 개수가 가변적이면 포인터가 효율적

214p.

- 이중포인터: 자료가 있는 곳을 2중으로 가르키는 포인터로, 이중 포인터가 가리키는 주소로 가면 자료가 아닌 주소값이 있음.
- 포인터에 확보되는 기억공간의 크기는 주소값을 가지기에 8byte(32bit 4byte)가 확보됨.

### 7장. 구조체와 공용체

225p.

- 구조체(structure): 서로 다른 자료형을 갖는 자료의 모임을 하나의 자료형으로 정의하여 사용하는 자료형
- 클래스 느낌인듯

232p.

- 실제로 메모리에 할당될 때는 구조체 멤버 중에서 가장 큰 자료형의 크기로 할당됨.

237p.

- 구조체 포인터의 멤버 참조
- dot(`.`): (*pt).name
- pointer(`->`): pt -> name
- 주로 `->` 사용한다고함.

240p.

- 구조체를 함수의 매개변수로 사용
- 해당 구조체 통째로 복사해서 사용, 구조체 내용 전체가 복사되서 시간, 기억공간 낭비 있음.
- 구조체 포인터를 매개변수로 사용하는식으로 해결

243p.

- `typedef`: 이미 존재하는 자료형에 새로운 이름을 붙이는 용도로 사용되는 키워드

246p.

- 공용체(union): 동일한 기억장소에 여러 유형의 자료를 저장하기 위해 선언한 자료형
- 구조체와 제반 내용 거의 동일
- 선언이 이루어지면 멤버 중 자료 크기가 가장 큰 메멉에 대해서만 기억공간이 할당되고, 기억공간 시작 위치부터 공용으로 사용함.
- 변수의 기억공간의 사용은 저장 공간이 충분하더라도 한 번에 1개의 값만 저장함.
- 사용될 자료의 자료형이 유동적일 경우 기억공간 효율적이게 사용 가능

### 8장. 파일처리함수

267p.

- 파일: 정보의 집합
- file 은 record 단위로 이루어짐, record 는 field 로 구성됨.
- 순차 파일: 레코드의 길이가 일정하지 않은 파일, 기록할 때 순서적으로 기록되고, 읽을 때도 순서적으로 읽히는 파일
- 랜덤 파일: 레코드의 길이가 일정한 파일
- 순차 파일은 일정하지 않은 레코드를 구별해 줄 필요가 있음.
- 구분 기호는 CR(Carriage Return), LF(Line Feed) 가 합해져서 사용됨.
- 텍스트 모드: 쓸 때 \n -> CR/LF, 읽을 때 CR/LF -> \n

278p.

- 랜덤 파일 처리
- 순차 파일에서는 각 레코드 길이가 일정하지 않아 레코드를 CR/LF 코드로 구분, 랜덤 파일에서는 각 레코드 길이가 일정하여 레코드 구분이 필요 없음.
- fixed length 를 가지고 있는 랜덤 파일은 variable length 레코드를 가진 순차 파일에 비해 어느 정도 기억 공간 낭비하지만 레코드 검색이 보다 빠르고 효율적임.

### 9장. 메모리 동적 할당

293p.

- C 기억공간 위치: data, heap, stack
- data: 전역변수, 정적변수
- heap: 프로그래머 필요에 의해 할당/소멸
- stack: 지역변수, 매개변수

294p.

- 변수 선언 단계에서 필요한 기억공간의 크기를 결정하는 것을 메모리 정적 할당(static allocation)이라함.
- 메모리 정적 할당의 경우, 보통 예상되는 크기보다 더 크게 잡거나, 정확히 알지 못해 기억 공간을 낭비할 수 있음.

298p.

- 메모리 동적 할당(dynamic allocation)은 heap 영역을 이용하여 프로그램 실행 중에 입력되는 자료에 맞게 기억공간 확보함.
- 많은 자료를 처리하는 배열의 크기를 실행 시간에 정의해야 하는 경우 유용함.
- 프로그램 실행 시 기억공간의 크기를 지정할 수 있고 재조정이 가능함.
- `malloc()`: memory allocation, `free()`

303p.

- `calloc()`: contiguous allocation
- 동적으로 heap 영역에 공간 할당, 할당된 기억공간 0으로 초기화
- `realloc()`: 동적 할당 받은 기억공간의 크기를 변경함.

305p.

- `memcmp()`: memory compare, `memcpy()`, `memset()`

309p.

- 문자열 처리 함수와 기억공간 관리 함수
- 기억공간 관리 함수:
- 인수, 리턴값 모두 void
- 실행의 끝을 알아야함. 그래서 인자로 n 받음
- 문자열 함수:
- 인수, 리턴값 대부분 char
- 시작 주소만 알면 null 문자('\0')으로 끝 인식하니 길이 알려줄 필요 없음.
